# Informatik Grundlagen - Vorlesungsplan

√úbersicht aller 22 Lektionen f√ºr das Modul "Informatik Grundlagen" im Bachelor Maschinenbau.
**Format:** Jeweils 3√ó45 Minuten pro Vorlesung (Theorie + Praktisches Python)

---

## Semesterplan: Zuordnung der 22 Termine

| Termin | Informatik-Theorie | Python-Praxis | Status |
|--------|-------------------|---------------|--------|
| V01 | Bin√§res Zahlensystem | Python Get Started: Variablen, print, input | ‚úÖ [Verf√ºgbar](lessons/V01-Binaeres-Zahlensystem/) |
| V02 | Flie√ükommazahlen | Eingaben/Ausgaben & Formatierung | ‚úÖ [Verf√ºgbar](lessons/V02-Fliesskommazahlen/) |
| V03 | Boolsche Algebra & Logische Schaltungen ‚Äì Teil 1 | Variablen Management & Datentypen | ‚úÖ [Verf√ºgbar](lessons/V03-Boolsche-Algebra-Teil1/) |
| V04 | Boolsche Algebra & Logische Schaltungen ‚Äì Teil 2 | Logische Ausdr√ºcke (Boolsche Algebra) |‚úÖ [Verf√ºgbar](lessons/V04-Boolsche-Algebra-Teil2/)|
| V05 | Programm-Ablauf-Pl√§ne ‚Äì Teil 1 | Verzweigungen (if, if-elif-else) | ‚úÖ [Verf√ºgbar](lessons/V05-Programm-Ablauf-Plaene-Teil1/) |
| V06 | Programm-Ablauf-Pl√§ne ‚Äì Teil 2 | Schleifen (for, while) ‚Äì Teil 1 | ‚úÖ [Verf√ºgbar](lessons/V06-Programm-Ablauf-Plaene-Teil2/) |
| V07 | Software Engineering (KISS, DRY, SRP) | Schleifen (for, while) ‚Äì Teil 2 | ‚úÖ [Verf√ºgbar](lessons/V07-Software-Engineering-KISS-DRY-SRP/) |
| V08 | Listen und Datenstrukturen ‚Äì Teil 1 | Listen & Datenstrukturen | ‚úÖ [Verf√ºgbar](lessons/V08-Listen-und-Datenstrukturen-Teil1/) |
| V09 | Listen und Datenstrukturen ‚Äì Teil 2 | Try-Catch (Fehlerbehandlung) | ‚úÖ [Verf√ºgbar](lessons/V09-Listen-und-Datenstrukturen-Teil2/) |
| V10 | Laufzeitanalyse & Algorithmik | Methoden/Funktionen ‚Äì Teil 1 | ‚úÖ [Verf√ºgbar](lessons/V10-Laufzeitanalyse-und-Algorithmik/) |
| V11 | GPTs, LLMs & K√ºnstliche Intelligenz | Methoden/Funktionen ‚Äì Teil 2 | ‚úÖ [Verf√ºgbar](lessons/V11-GPTs-LLMs-KI/) |
| V12 | Prompt Engineering & Best Practices | Imports & Code auf mehrere Dateien verteilen | ‚úÖ [Verf√ºgbar](lessons/V12-Prompt-Engineering-Best-Practices/) |
| V13 | Betriebssysteme & Rechnerarchitektur ‚Äì Teil 1 | Plots & Grafiken (Matplotlib) ‚Äì Teil 1 | ‚úÖ [Verf√ºgbar](lessons/V13-Betriebssysteme-Rechnerarchitektur-Teil1/) |
| V14 | Betriebssysteme & Rechnerarchitektur ‚Äì Teil 2 | Plots & Grafiken (Matplotlib) ‚Äì Teil 2 | ‚úÖ [Verf√ºgbar](lessons/V14-Betriebssysteme-Rechnerarchitektur-Teil2/) |
| V15 | Netzwerktechnik Grundlagen & Protokolle ‚Äì Teil 1 | Gro√üe Datenmengen verarbeiten ‚Äì Teil 1 | ‚úÖ [Verf√ºgbar](lessons/V15-Netzwerktechnik-Grundlagen-Protokolle-Teil1/) |
| V16 | Netzwerktechnik Grundlagen & Protokolle ‚Äì Teil 2 | Gro√üe Datenmengen verarbeiten ‚Äì Teil 2 | üîÑ In Planung |
| V17 | Kryptografie ‚Äì Teil 1 | Netzwerk-Programmierung (Basics: Socket, HTTP) ‚Äì Teil 1 | ‚úÖ [Verf√ºgbar](lessons/V17-Kryptografie-Teil1/) |
| V18 | Kryptografie ‚Äì Teil 2 | Netzwerk-Programmierung (Basics: Socket, HTTP) ‚Äì Teil 2 | üîÑ In Planung |
| V19 | Datenbanken ‚Äì Teil 1 | Datenbankverbindung & SQL ‚Äì Teil 1 | üîÑ In Planung |
| V20 | Datenbanken ‚Äì Teil 2 | Datenbankverbindung & SQL ‚Äì Teil 2 | üîÑ In Planung |
| V21 | **Wiederholung & Pr√ºfungsvorbereitung** | **Wiederholung & Pr√ºfungsvorbereitung** | üîÑ In Planung |
| V22 | **Wiederholung & Pr√ºfungsvorbereitung** | **Wiederholung & Pr√ºfungsvorbereitung** | üîÑ In Planung |

---

## √úbersicht: Thematische Ordnung

### Informatik-Theorie Reihenfolge

1. **Bin√§res Zahlensystem** (V01)
   - Stellenwertsysteme allgemein (Dezimal, Bin√§r, Hexadezimal, Oktal)
   - Umrechnung zwischen verschiedenen Zahlensystemen
   - Bin√§re Rechenoperationen (Addition, Subtraktion)
   - Negative Zahlen im Computer (Zweierkomplement)
   - Praktische Anwendung: Bit-Masken und Bit-Manipulation

2. **Flie√ükommazahlen** (V02)
   - IEEE 754 Standard f√ºr Gleitkommadarstellung
   - Aufbau: Vorzeichen, Exponent, Mantisse
   - Rundungsfehler und Genauigkeitsprobleme
   - Spezielle Werte (NaN, Inf, -Inf)
   - Best Practices beim Vergleichen von Flie√ükommazahlen

3. **Boolsche Algebra & Logische Schaltungen ‚Äì Teil 1** (V03)
   - Grundlegende logische Operatoren (AND, OR, NOT)
   - Wahrheitstabellen erstellen und interpretieren
   - Logische Ausdr√ºcke formulieren
   - Einfache logische Schaltungen
   
   **Boolsche Algebra & Logische Schaltungen ‚Äì Teil 2** (V04)
   - Erweiterte Operatoren (XOR, NAND, NOR)
   - De Morgan'sche Gesetze und Vereinfachungsregeln
   - Logische Schaltungen: Halbaddierer und Volladdierer
   - Multiplexer und Demultiplexer
   - Praktische Anwendungen in digitalen Schaltungen

4. **Programm-Ablauf-Pl√§ne ‚Äì Teil 1** (V05)
   - Symbole und Notation (DIN 66001, ISO 5807)
   - Grundstrukturen: Sequenz, Verzweigung, Schleife
   - Einfache PAPs erstellen und lesen
   - √úbungen: Alltagsprobleme als PAP darstellen
   
   **Programm-Ablauf-Pl√§ne ‚Äì Teil 2** (V06)
   - Von PAP zu Pseudocode und zur√ºck
   - Komplexe Algorithmen visualisieren
   - Dokumentation von Programmabl√§ufen
   - Vergleich verschiedener Darstellungsformen

5. **Software Engineering (KISS, DRY, SRP)** (V07)
   - KISS-Prinzip: Einfachheit als Designziel
   - DRY-Prinzip: Code-Duplikation vermeiden
   - Single Responsibility Principle: Eine Aufgabe pro Komponente
   - Code-Qualit√§t und Wartbarkeit
   - Refactoring-Strategien f√ºr bessere Code-Struktur
   - Code Reviews und Best Practices

6. **Listen und Datenstrukturen ‚Äì Teil 1** (V08) ‚úÖ
   - Arrays: Aufbau und Zugriff mit O-Notation
   - Verkettete Listen (Einfach und Doppelt verkettet)
   - Stacks (LIFO-Prinzip) und Anwendungen
   - Queues (FIFO-Prinzip) und Anwendungen
   - Zeitkomplexit√§t verschiedener Operationen
   
   **Listen und Datenstrukturen ‚Äì Teil 2** (V09) ‚úÖ
   - B√§ume: Bin√§rb√§ume und Bin√§re Suchb√§ume (BST)
   - Terminologie: Wurzel, Bl√§tter, H√∂he, Tiefe, vollst√§ndig, balanciert
   - BST-Operationen: Suchen, Einf√ºgen, L√∂schen mit O-Notation (Best/Average/Worst Case)
   - Traversierungen: Inorder (LWR), Preorder (WLR), Postorder (LRW), Level-Order (Breitensuche)
   - Hash-Tabellen: Aufbau, Hash-Funktionen, Load Factor Œ±
   - Kollisionsbehandlung: Chaining (verkettete Listen) vs. Open Addressing (Linear Probing, Quadratic Probing)
   - Komplexit√§tsanalyse aller Operationen: O(1) vs. O(n)

7. **Laufzeitanalyse & Algorithmik** (V10)
   - O-Notation (Big-O, Omega, Theta)
   - Zeitkomplexit√§t vs. Speicherkomplexit√§t
   - Best-Case, Average-Case, Worst-Case
   - Analyse einfacher Algorithmen und Schleifen
   - Rekursion und rekursive Komplexit√§t
   - Sortieralgorithmen im Vergleich: Bubble Sort, Quick Sort, Merge Sort

8. **GPTs, LLMs & K√ºnstliche Intelligenz** (V11) ‚úÖ
   - Geschichte der KI: Von Symbolischer KI √ºber Machine Learning zu Deep Learning
   - KI-Paradigmen im Vergleich: Expertensysteme vs. ML vs. DL
   - Neuronale Netze: Perceptron, Multilayer Networks, Aktivierungsfunktionen, Backpropagation
   - Transformer-Architektur: Self-Attention-Mechanismus im Detail
   - Multi-Head Attention: Parallel processing verschiedener Beziehungsarten
   - Query, Key, Value Vektoren und deren Bedeutung
   - Large Language Models (LLMs): GPT (decoder-only), BERT (encoder-only), LLaMA
   - Training Pipeline: Pretraining, Supervised Fine-Tuning, RLHF (Reinforcement Learning from Human Feedback)
   - Anwendungsbereiche: Textgenerierung, √úbersetzung, Code-Generierung, Reasoning
   - Halluzinationen: Ursachen, Beispiele, Gegenma√ünahmen (RAG, Fact-Checking, Confidence Scoring)
   - Bias in KI: Historische Daten, Proxy-Diskriminierung, Fairness-Constraints
   - Risikobewertung f√ºr verschiedene Use Cases (Medizin, Code-Gen, Recruiting, etc.)
   - Zukunftsperspektiven: Multimodale Modelle, Effizienz, Reasoning-F√§higkeiten

9. **Prompt Engineering & Best Practices** (V12)
   - Was ist Prompt Engineering und warum ist es wichtig?
   - Anatomie eines guten Prompts: Kontext, Aufgabe, Format, Constraints
   - Zero-Shot, One-Shot und Few-Shot Learning
   - Chain-of-Thought Prompting f√ºr komplexe Aufgaben
   - Role-Based Prompting: System-Prompts effektiv nutzen
   - Prompt-Patterns: ReAct, Tree-of-Thoughts, Self-Consistency
   - Iteratives Prompt-Design und Refinement
   - Temperatur und andere Parameter verstehen
   - H√§ufige Fehler und wie man sie vermeidet
   - Ethik im Prompt Engineering: Bias vermeiden, Sicherheit gew√§hrleisten
   - Praktische Anwendungen: Code-Generierung, Datenanalyse, Content-Erstellung
   - Tools und Frameworks f√ºr Prompt Engineering

10. **Betriebssysteme & Rechnerarchitektur ‚Äì Teil 1** (V13)
   - Von-Neumann-Architektur: CPU, RAM, I/O
   - CPU-Aufbau: ALU, Steuerwerk, Register
   - Fetch-Decode-Execute-Zyklus
   - Cache-Hierarchie (L1, L2, L3)
   
   **Betriebssysteme & Rechnerarchitektur ‚Äì Teil 2** (V14)
   - Aufgaben eines Betriebssystems
   - Prozessverwaltung und Scheduling-Algorithmen
   - Prozesse vs. Threads
   - Virtueller Speicher und Paging
   - Dateisysteme und deren Organisation

11. **Netzwerktechnik Grundlagen & Protokolle ‚Äì Teil 1** (V15) ‚úÖ
   - OSI-Modell: 7 Schichten im Detail (Physical, Data Link, Network, Transport, Session, Presentation, Application)
   - Protokoll-Zuordnung und Encapsulation-Prozess
   - TCP/IP-Modell: 4 Schichten im Vergleich zum OSI-Modell
   - IPv4-Adressen: 32-bit, Aufbau, private/public Ranges (RFC 1918), spezielle Adressen (127.0.0.1, 0.0.0.0, 255.255.255.255)
   - IPv6-Adressen: 128-bit, Aufbau, Shortening-Regeln, Adresstypen (Link-Local, Global Unicast, Multicast)
   - Subnetting mit CIDR-Notation: Netzwerk-/Host-Bits berechnen, Subnetz-Aufteilung, praktische Anwendungen
   - Mermaid-Diagramme f√ºr Visualisierungen (OSI-Schichten, TCP/IP-Vergleich, Sequenz, State, Class, Pipeline)
   
   **Netzwerktechnik Grundlagen & Protokolle ‚Äì Teil 2** (V16)
   - TCP vs. UDP: Verbindungsorientiert vs. verbindungslos
   - HTTP/HTTPS und das Request-Response-Modell
   - REST-APIs: Prinzipien und Methoden
   - DNS: Name Resolution und Hierarchie
   - Ports und Socket-Kommunikation

12. **Kryptografie ‚Äì Teil 1** (V17) ‚úÖ
    - Kryptografie-Grundlagen: Geschichte (Caesar-Chiffre), Kerckhoffs' Prinzip
    - Symmetrische Verschl√ºsselung: DES (Data Encryption Standard), AES (Advanced Encryption Standard)
    - Asymmetrische Verschl√ºsselung: RSA (Rivest-Shamir-Adleman) mit mathematischen Details
    - RSA-Workflow: Schl√ºsselerzeugung, Verschl√ºsselung, Entschl√ºsselung
    - Hybrid-Verschl√ºsselung: Kombination von symmetrisch + asymmetrisch f√ºr gro√üe Datenmengen
    - Schl√ºsselaustausch-Problematik und L√∂sungsans√§tze
    - Anwendungsbeispiele: HTTPS, E-Mail-Verschl√ºsselung, VPN
    
    **Kryptografie ‚Äì Teil 2** (V18)
    - Hash-Funktionen und deren Eigenschaften (SHA-256, MD5)
    - Public-Key-Infrastruktur (PKI) und Zertifikate
    - Digitale Signaturen zur Authentifizierung
    - Anwendungsbeispiele: TLS/SSL, HTTPS
    - Passwort-Hashing und Salting

13. **Datenbanken ‚Äì Teil 1** (V19)
    - Relationale Datenbanken und das Tabellenmodell
    - Entit√§ten, Attribute und Beziehungen
    - SQL-Grundlagen: SELECT, FROM, WHERE
    - SQL-DML: INSERT, UPDATE, DELETE
    - Prim√§r- und Fremdschl√ºssel zur Datenintegrit√§t
    - JOINs: INNER, LEFT, RIGHT, FULL
    - Aggregatfunktionen: COUNT, SUM, AVG, MIN, MAX
    
    **Datenbanken ‚Äì Teil 2** (V20)
    - Normalisierung (1NF, 2NF, 3NF)
    - Indizes zur Performance-Optimierung
    - Transaktionen und ACID-Prinzipien
    - NoSQL-Datenbanken: Wann und warum?
    - MongoDB, Redis, Cassandra im √úberblick
    - KI und Datenbanken: Vector Databases f√ºr Embeddings

---

### Python Reihenfolge

1. **Python Get Started: Variablen, print, input** (V01)
   - Installation und Entwicklungsumgebungen (IDLE, VS Code, PyCharm)
   - Erste Programme: Ausgabe mit `print()`
   - Variablen deklarieren und zuweisen
   - Benutzereingaben mit `input()` einlesen
   - Kommentare f√ºr lesbaren Code

2. **Eingaben/Ausgaben & Formatierung** (V02)
   - String-Formatierung (f-Strings, `.format()`, %-Operator)
   - Zahlen formatieren (Dezimalstellen, Tausender-Trenner)
   - Ausgaben in Dateien schreiben und Dateien einlesen
   - `print()`-Parameter: `sep`, `end`, `file`
   - Escape-Sequenzen und mehrzeilige Strings

3. **Variablen Management & Datentypen** (V03)
   - Grundlegende Datentypen: `int`, `float`, `str`, `bool`
   - Type Casting und Type Checking (`int()`, `type()`, `isinstance()`)
   - Unver√§nderliche vs. ver√§nderliche Typen (Immutable vs. Mutable)
   - Variablen-Scope: Lokal vs. Global
   - Multiple Assignment und Value Unpacking

4. **Logische Ausdr√ºcke (Boolsche Algebra)** (V04)
   - Vergleichsoperatoren (`==`, `!=`, `<`, `>`, `<=`, `>=`)
   - Logische Operatoren (`and`, `or`, `not`)
   - Wahrheitswerte und Kurzschlussauswertung (Short-Circuit Evaluation)
   - Komplexe Bedingungen formulieren und vereinfachen
   - Truthy und Falsy Values in Python

5. **Verzweigungen (if, if-elif-else)** (V05)
   - Einfache `if`-Anweisungen
   - `if-else` f√ºr bin√§re Entscheidungen
   - `if-elif-else` f√ºr mehrfache Verzweigungen
   - Verschachtelte Bedingungen und deren Lesbarkeit
   - Tern√§rer Operator f√ºr kompakte Ausdr√ºcke

6. **Schleifen (for, while) ‚Äì Teil 1** (V06)
   - `for`-Schleifen mit `range()` 
   - Iterieren √ºber Listen, Strings und andere Iterables
   - `while`-Schleifen mit Abbruchbedingungen
   - Endlos-Schleifen vermeiden
   
   **Schleifen (for, while) ‚Äì Teil 2** (V07)
   - `break` und `continue` zur Schleifensteuerung
   - Verschachtelte Schleifen und deren Komplexit√§t
   - `else`-Klausel bei Schleifen
   - List Comprehensions als kompakte Alternative
   - Praktische √úbungen: Muster, Zahlenreihen, Algorithmen

7. **Listen & Datenstrukturen** (V08) ‚úÖ
   - Listen erstellen, indexieren und slicen
   - Wichtige List-Methoden: `append()`, `insert()`, `extend()`, `remove()`, `pop()`, `clear()`, `index()`, `count()`, `sort()`, `reverse()`, `copy()`
   - Tupel als unver√§nderliche Listen
   - Built-in Funktionen: `sorted()`, `sum()`, `all()`, `any()`, `zip()`
   - Operatoren f√ºr Listen: `+`, `*`, `in`, `del`
   - Slicing und Extended Unpacking
   - Aliasing vs. Copying (Shallow vs. Deep Copy)
   - Listen als Stacks (LIFO) und Queues (FIFO)

8. **Try-Catch (Fehlerbehandlung)** (V09) ‚úÖ
   - Exception-Konzept: Fehlerbehandlung statt Programmabsturz
   - `try-except`-Bl√∂cke: Code gegen Fehler absichern
   - `else`-Klausel: Code f√ºr erfolgreichen Try-Block
   - `finally`-Klausel: Cleanup-Code der immer l√§uft
   - Mehrere Exception-Typen abfangen: Spezifisch vs. generisch
   - Exception-Objekte: Zugriff mit `as e`, Fehlermeldungen extrahieren
   - `raise`-Statement: Eigene Exceptions werfen
   - Benutzerdefinierte Exceptions: Von `Exception` ableiten
   - Exception-Hierarchie: ValueError, TypeError, KeyError, FileNotFoundError, PermissionError, IndexError, ZeroDivisionError
   - JSON-Modul: `json.load()`, `json.dump()`, `json.JSONDecodeError`
   - Best Practices: EAFP-Prinzip ("Easier to Ask for Forgiveness than Permission")
   - Anwendung: Robuste Eingabe-Validierung, Datei-Operationen, Konfigurationssysteme

9. **Methoden/Funktionen ‚Äì Teil 1** (V10) ‚úÖ
   - Funktionen definieren mit `def`
   - Parameter und R√ºckgabewerte (`return`)
   - Default-Parameter und ihre Fallstricke
   - Positionale vs. Keyword Arguments
   - Multiple Return Values als Tupel
   - Funktionen als First-Class Objects
   - Scope und LEGB-Regel (Local, Enclosing, Global, Built-in)
   - Docstrings f√ºr Dokumentation
   - Zeit-Messung mit `time.time()`
   
   **Methoden/Funktionen ‚Äì Teil 2** (V11) ‚úÖ
   - Keyword-Only Arguments mit `*` Separator
   - `*args` f√ºr variable Anzahl positionaler Parameter (Tupel)
   - `**kwargs` f√ºr variable Anzahl benannter Parameter (Dictionary)
   - Vollst√§ndige Parametersignatur: Reihenfolge und Kombinationen
   - Unpacking-Operatoren: `*iterable` und `**dict` bei Aufrufen und Definitionen
   - Dictionary Merging mit `{**dict1, **dict2}`
   - Lambda-Funktionen: Syntax, Verwendung, Einschr√§nkungen
   - Funktionale Programmierung: `map()`, `filter()` vs. List Comprehensions
   - Type Hints (PEP 484): Parameter- und R√ºckgabewert-Annotationen
   - `typing`-Modul: `List`, `Dict`, `Optional`, `Union`, `Any`, `Callable`
   - Docstring-Formate: Google Style vs. NumPy Style
   - JSON mit `indent` und `ensure_ascii` f√ºr sch√∂ne Formatierung
   - DateTime: `.isoformat()` und `.strftime()` f√ºr Zeitstempel
   - Fehlertolerante Batch-Verarbeitung mit `try-except` in Schleifen
   - Praktische √úbungen: Log-Formatter, Statistik-Funktion, LLM API-Wrapper, Conversation Manager mit Persistenz

10. **Imports & Code auf mehrere Dateien verteilen** (V12) ‚úÖ
    - Module importieren: `import`, `from ... import`, `as` Aliase
    - Eigene Module erstellen und organisieren
    - Packages und `__init__.py`, `__all__` f√ºr Public API
    - `if __name__ == "__main__":` Pattern f√ºr Dual-Use-Module
    - Relative vs. absolute Imports in Package-Hierarchien
    - Virtuelle Umgebungen: `python -m venv`, `pip freeze`, `requirements.txt`
    - CLI-Tools mit `argparse`: ArgumentParser, add_argument()
    - Praktische √úbungen: Eigene Module, Packages mit Submodulen, venv-basiertes CLI-Tool

11. **Plots & Grafiken (Matplotlib) ‚Äì Teil 1** (V13)
    - Matplotlib installieren und importieren
    - Grundlegende Plot-Typen: Liniendiagramme
    - Achsenbeschriftung, Titel und Legenden
    - Scatter Plots f√ºr Datenpunkte
    - Farben und Marker anpassen
    
    **Plots & Grafiken (Matplotlib) ‚Äì Teil 2** (V14)
    - Bar Charts und Histogramme
    - Mehrere Plots in einer Figure (Subplots)
    - Verschiedene Achsenskalierungen (logarithmisch, etc.)
    - Anpassung: Linien-Stile, F√ºllungen, Annotationen
    - Plots speichern in verschiedenen Formaten (PNG, PDF, SVG)
    - Praktische √úbung: Messdaten visualisieren

12. **Gro√üe Datenmengen verarbeiten ‚Äì Teil 1** (V15) ‚úÖ
    - Speicher-effizientes Einlesen gro√üer Dateien: for-Schleife auf file-Objekt vs. readlines()
    - Generator-Konzept: yield-Keyword, Lazy Evaluation, Memory-Effizienz O(1) vs. O(n)
    - Generator-Funktionen: Countdown-Beispiel, Zeilen-Filter, Pipeline-Architektur
    - Generator-Pipelines: Verkettung f√ºr Daten-Transformation (Extract-Transform-Load)
    - Iterator-Protokoll: __iter__() und __next__(), StopIteration
    - Iterator vs. Iterable: Unterschiede, Exhaustion-Problem, mehrfache Iteration
    - Praktische Iterator-Beispiele: CountDown-Klasse, Fibonacci-Iterator
    - CSV-Modul: csv.reader(), csv.writer(), csv.DictReader(), csv.DictWriter()
    - CSV Best Practices: newline=''-Parameter unter Windows, Encoding, delimiter
    - Built-in Funktionen: iter(), next() mit default-Parameter
    - itertools.tee(): Generator klonen f√ºr mehrfache Analysen
    - Anwendungen: Log-Datei-Analyse mit Generator-Pipeline, E-Commerce ETL mit decimal.Decimal
    
    **Gro√üe Datenmengen verarbeiten ‚Äì Teil 2** (V16)
    - Pandas: Installation und erste Schritte
    - DataFrames erstellen und manipulieren
    - Daten filtern, sortieren und aggregieren
    - Performance-Tipps: Vektorisierung statt Schleifen
    - Praktische √úbung: Analyse eines Datensatzes

13. **Netzwerk-Programmierung (Basics: Socket, HTTP) ‚Äì Teil 1** (V17) ‚úÖ
    - Socket-Modul: socket.socket(), Konstanten (AF_INET, SOCK_STREAM, SOL_SOCKET, SO_REUSEADDR)
    - Server-Socket-Methoden: .bind(), .listen(), .accept()
    - Client-Socket-Methoden: .connect()
    - Daten√ºbertragung: .send(), .sendall(), .recv() mit Byte-Encoding/Decoding
    - Socket-Verwaltung: .close(), .setsockopt(), .settimeout()
    - TCP/IP Client-Server-Architektur: Ablauf und Best Practices
    - Multi-Client-Server: Sequenzielle Verarbeitung, Threading (Vorschau)
    - HMAC-√§hnliche Authentifizierung: hashlib.sha256(), .hexdigest(), Message Authentication Codes
    - Praktische √úbungen: Echo-Server, CNC-Temperatur-Monitor (JSON), Multi-Client Sensor-Server, Roboter-Steuerung, Sichere Maschinen-Kommunikation
    
    **Netzwerk-Programmierung (Basics: Socket, HTTP) ‚Äì Teil 2** (V18)
    - HTTP-Protokoll verstehen
    - HTTP-Requests mit `requests`-Bibliothek
    - GET und POST Requests
    - JSON-Daten √ºber APIs abrufen und parsen
    - Status Codes und Error Handling
    - Praktische √úbung: Wetter-API oder √§hnliches nutzen

14. **Datenbankverbindung & SQL ‚Äì Teil 1** (V19)
    - SQLite: Eingebettete Datenbank ohne Server
    - Verbindung herstellen mit `sqlite3`-Modul
    - Tabellen erstellen (CREATE TABLE)
    - Daten einf√ºgen (INSERT)
    - Einfache Queries (SELECT)
    
    **Datenbankverbindung & SQL ‚Äì Teil 2** (V20)
    - Prepared Statements gegen SQL-Injection
    - Daten aktualisieren (UPDATE) und l√∂schen (DELETE)
    - Transaktionen: Commit und Rollback
    - Cursor-Objekte und fetchall()/fetchone()
    - Context Manager f√ºr sichere Verbindungen
    - Praktische √úbung: Datenbank f√ºr KI-Training-Logs erstellen